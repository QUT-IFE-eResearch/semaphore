"use strict";
/*!
 * redis-jobq
 * Usage example:
 * var JobQueue = require('JobQueue');
 * var jobs = new JobQueue();
 * jobs.submit
 *
 * jq:jobTypes set
 * jq:job:<id> hash
 * jq:jobs set
 * jq:jobs:<type> set
 * jq:jobs:<type>:queue:priorities sortedset
 * jq:jobs:<type>:queue:<priority> list
 * jq:jobs:<type>:queue set
 * jq:jobs:<type>:run set
 * jq:jobs:<type>:hold set
 * jq:jobs:<type>:wait set
 * jq:jobs:<type>:end set
 * jq:jobs:<type>:reserve set
 */

// Module dependencies.
//var EventEmitter = require('events').EventEmitter;
var logger = require('jsx').createLogger(module);
var redis = require('redis');

var noop = function(){};

function isUndef(v){
  return (typeof v === 'undefined');
}

function errorSameState(state) {
  return new Error('Job is already in state `' + state + '`.');
}
function errorTypeNumber(v) {
  return new Error('Value of ' + v + ' must be a number.');
}
function errorUneditable(jobId) {
  return new Error('Any changes to job ' + jobId + ' is not allowed at this state.');
}

var STATES = {
      QUEUE: 'queue',
      RUN: 'run',
      HOLD: 'hold', // paused by request
      WAIT: 'wait', //scheduled job
      END: 'end'
};

var PRIORITIES = {
      LOW: 10,
      NORMAL: 0,
      HIGH: -10,
      CRITICAL: -20
};

var RKEY = {};

// jq:jobTypes SET of job types
RKEY.JOBTYPES = 'jq:jobTypes'; 
// jq:jobs SET of all job ids
RKEY.JOBS = 'jq:jobs';
// jq:jobs:<type> SET of job ids with specific type
RKEY.type = function(type) { return RKEY.JOBS + ':' + type; };
// jq:job:<id> HASH of job details
RKEY.job = function(id) { return 'jq:job:' + id; };
// jq:jobs:<type>:queue:priorities SORTEDSET of available priorities
RKEY.priorities = function(type) { return RKEY.JOBS + ':' + type + ':' + STATES.QUEUE + ':priorities'; };
// jq:jobs:<type>:queue:<priority> LIST of the job ids in queue based on priority
RKEY.queue = function(type, priority) { return RKEY.JOBS + ':' + type + ':' + STATES.QUEUE + ':' + priority; };
// jq:jobs:<type>:<state> SET of job ids in particular state
RKEY.state = function(type, state) { return RKEY.JOBS + ':' + type + ':' + state; };

function ClassObject() {}
ClassObject.prototype = Object;
function Class(baseClass, definer) {
  if (typeof baseClass !== 'function') {
    baseClass = ClassObject.prototype;
  }
  var constructor = baseClass;
  if (typeof definer === 'function') {
    var $proto = Object.create(baseClass.prototype);
    constructor = definer($proto);
    constructor.__proto__ = baseClass;
    //constructor.super = baseClass;
    constructor.prototype = $proto;
    constructor.className = constructor.name;
  }
  return constructor;
}

/**
 * @classdesc A job represents a task in the priority queue.
 */
var Job = Class( Object, function($proto) {
  function Job(prop) {
    this.data = prop.data;
    Object.defineProperties(this, {
      id : { value: prop.id || 0, enumerable:true },
      type : { value: prop.type || 'default', enumerable: true },
      _priority : { value: prop.priority || PRIORITIES.NORMAL, writable:true },
      _state : { value: prop.state, writable:true },
      _attempts : { value: prop.attempts || 0, writable:true },
      _maxAttempts : { value: prop.maxAttempts || 1, writable:true },
      createdAt : { value: prop.createdAt || Date.now(), enumerable:true },
      _updatedAt : { value: prop.updatedAt || 0, writable:true },
      _runAt : { value: prop.runAt || 0, writable:true },
      _endAt : { value: prop.endAt || 0, writable:true }
    });
  }
  Job.PRIORITIES = PRIORITIES;
  Job.STATES = STATES;
  
  Object.defineProperties($proto, {
    priority : { enumerable: true, 
      get: function() { return this._priority; },  
      set: function(val) {
        if (typeof val !== 'number') throw errorTypeNumber('val');
        if (val !== this._priority) this._priority = val;
      }
    },
    state : { enumerable: true, get: function() { return this._state; } },
    attempts : { enumerable: true, get: function() { return this._attempts; } },
    maxAttempts : { enumerable: true, get: function() { return this._maxAttempts; } },
    updatedAt : { enumerable: true, get: function() { return this._updatedAt; } },
    runAt : { enumerable: true, get: function() { return this._runAt; } },
    endAt : { enumerable: true, get: function() { return this._endAt; } }
  });
  return Job;
});

/**
 * @classdesc JobQueue is a priority queue implemented using redis as the data storage backend.
 */
var JobQueue = module.exports = Class( Object, function($proto) {
  /** 
   * Creates a new job Queue. 
   * @constructor
   * @param [options]
   * @param {Number} [options.port=6379] Redis server port number
   * @param {String} [options.host='127.0.0.1' Redis server host name or IP Address
   * @param {Number} [options.db=0] Redis db index
   * @param {Object} [options.redis] Other options accepted by node redis client
   * @param {errorCallback} cb If specified, cb will be called in an event of sucessfull connection or any error.
   * @api public 
   */
  function JobQueue(options, cb) {
    if (!cb && typeof options === 'function') {
      cb = options;
      options = null;
    }
    var redisClient;
    if (options) {
      redisClient = redis.createClient(options.port, options.host, options.redis);
      if (options.db) redis.select(options.db, noop);
    }
    else redisClient = redis.createClient();
    this._rc = redisClient;
    this.maxAttempts = 1;
    if (cb) {
      redisClient.once('error', function(err){
        logger.error(err);
        redisClient.end();
        cb(err);
      });
      redisClient.once('connect', function(){
        cb();
      });
    }
  }
  
  /**
   * Create a job with the given options containing `type`, `data` and `priority`, and assign a unique id to the job.
   * This will return a job with no state. Use JobQueue.submit() to start queueing.
   * <pre><code>
   *   var jobs = new JobQueue();
   *   jobs.create({type:'email', data:''}, function(err, job) { jobs.submit(job); } );
   * </code></pre>
   *
   * @param options
   * @param {String} [options.type='default'] The type of the job
   * @param {Number} [options.priority=0] The priority of the job
   * @param {Object} [options.data] The additional/custom information needed for the job
   * @param {jobCallback} cb(err, job) job is the newly created job
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.create = function(options, cb) {
    var self = this;
    self._rc.incr('jq:jobs:lastId', function(err, id){
      if (err) return cb(err);
      //console.log(self);
      var job = new Job({id:id, type:options.type, data:options.data, priority:options.priority, maxAttempts:self.maxAttempts});
      self.save(job, cb);
    });
    return self;
  };
  
  /**
   * Save a job. The passed data will first be compared to the stored data before any changes is applied.
   *
   * @param {Job} job
   * @param {jobCallback} cb(err, job)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.save = function(job, cb) {
    //if (job.state === STATES.RUN) throw errorUneditable(job.id);
    cb = cb || noop;
    var rc = this._rc;
    var key = RKEY.job(job.id);
    var now = Date.now();
    // check if this object has been modified and compare with existing value
    rc.hgetall(key, function(err, obj) {
      if (err) cb(err);
      var multi = rc.multi();
      var jobhash = {};
      var datastr = JSON.stringify(job.data);
      var isModified = false;
      if (obj) { // Job has been saved previously, just need to update the modified properties
        if ((job.data != null) && (!obj.data || obj.data.length !== datastr.length || obj.data !== datastr)) {
          jobhash.data = datastr;
          isModified = true;
        }
        if (job.priority != null && job.priority !== obj.priority) {
          jobhash.priority = '' + job.priority;
          isModified = true;
          if (job.state === STATES.QUEUE) {
            multi.lrem(RKEY.queue(job.type, obj.priority), 1, job.id);
            multi.rpush(RKEY.queue(job.type, job.priority), job.id);
            multi.lrem(RKEY.queue('*', obj.priority), 1, job.id);
            multi.rpush(RKEY.queue('*', job.priority), job.id);
          }
        }
        if (job.maxAttempts != null && job.maxAttempts !== obj.maxAttempts) {
          jobhash.maxAttempts = job.maxAttempts;
          isModified = true;
        }
        logger.debug('update existing job: %s', job.id);
      } else { // A newly created job that has never been saved
        isModified = true;
        jobhash = {
          type: '' + job.type,
          data: datastr,
          priority: ''+job.priority,
          attempts: ''+job.attempts,
          maxAttempts: ''+job.maxAttempts,
          createdAt: ''+job.createdAt,
          runAt: ''+job.runAt,
          endAt: ''+job.endAt
        };
        multi.sadd(RKEY.JOBTYPES, job.type)
             .sadd(RKEY.JOBS, job.id)
             .sadd(RKEY.type(job.type), job.id);
        logger.debug('save new job: %s', job.id);
      }
      if (isModified) {
        jobhash.updatedAt = ''+now;
        job._updatedAt = now;
        multi.hmset(key, jobhash).exec(function(err){
          if (err) cb(err);
          else cb(null, job);
        });
      } else {
        multi = null;
        cb(null, job);
      }
    });
    return this;
  };
  
  /**
   * Enqueue a newly created Job to the queue.
   *
   * @param {Job} job
   * @param {jobCallback} cb(err, job)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.submit = function(job, cb) {
    if (job.state in {run:'run', wait:'wait', queue:'queue'}) throw new Error('Submitting a job with state run, wait, or queue is not allowed.');
    cb = cb || noop;
    this.enqueue(job, function(e, r){
      if (e) return cb(e);
      job._state = STATES.QUEUE;
      cb(e, job);
    });
    return this;
  };

  /** 
   * Low level function, no error checking. Use submit() instead 
   * @param {Job} job
   * @param {errorCallback} cb(err)
   * @return {JobQueue} for chaining
   */
  $proto.enqueue = function(job, cb) {
    var sq = STATES.QUEUE;
    var multi = this._rc.multi();
    mSetJobState(multi, job.id, job.type, sq, job.state);
    multi.zadd(RKEY.priorities(job.type), job.priority, job.priority); // Add a priority to priorities sorted set
    multi.rpush(RKEY.queue(job.type, job.priority), job.id);
    multi.zadd(RKEY.priorities('*'), job.priority, job.priority);
    multi.rpush(RKEY.queue('*', job.priority), job.id);
    multi.exec(cb);
    return this;
  };
  
  /** This is a low level API, use `process` is preferred.
   * @param {String} [options]
   * @param {String} [options.type='*'] Use '*' to get job of any type
   * @param {String} [options.state='']  The state of the job after it has been removed from the queue
   * @param {Number} [timeout=0] Maximum number of seconds to block, 0 means block indefinitely. The value must be an integer.
   * @param {jobIdCallback} cb(err, id)
   * @return {JobQueue} for chaining
   */
  $proto.dequeue = function(options, cb) { 
    if (!cb && (typeof options === 'function')) { 
      cb = options;
      options = {};
    } else {
      cb = cb || noop;
    }
    options = options || {};
    var type = options.type || '*';
    var timeout = options.timeout || 0;
    var nextState = options.state || '';
    logger.debug('[JobQueue.dequeue(%s, %s, cb)]', type, timeout);
    var rc = this._rc;
    // get a list of all priorities
    rc.zrange(RKEY.priorities(type), 0, -1, blpopFromPriorities);
    function blpopFromPriorities(err, priorities) {
      //logger.debug('priorities='+priorities);
      if (err || !priorities || priorities.length === 0) return cb(err);
      var params = priorities.map(function(p) { return RKEY.queue(type, p); });
      params.push(timeout);
      logger.debug('[JobQueue.dequeue] blpop params:', params);
      rc.blpop(params, checkResult);
    }
    function checkResult(err, arr) {
      logger.debug('[JobQueue.dequeue] checkResult arr:', arr);
      if (err || !arr || arr.length === 0) return cb(err); //return nothing, all queues are empty
      var qname = arr[0];
      var priority = qname.substring(qname.lastIndexOf(':')+1);
      var id = arr[1];
      var multi = rc.multi();
      if (type === '*') {
        // find type using id, delete from the queue of that type
        getJobType(rc, id, function(err, actualType) {
          if (err) return cb(err);
          multi.lrem(RKEY.queue(actualType, priority), 1, id);
          finalize(multi, actualType, id);
        });
      } else {
        multi.lrem(RKEY.queue('*', priority), 1, id);
        finalize(multi, type, id);
      }
    }
    function finalize(multi, jobType, jobId) {
      mSetJobState(multi, jobId, jobType, nextState, STATES.QUEUE);
      multi.exec(function(err, arr){
        if (err) return cb(err);
        else cb(null, jobId);
      });
    }
    return this;
  };

  /**
   * Process jobs with the given `type`, invoking `cb(job, done)`.
   * Calling this method will automatically and continuously dequeue the queue and perform the function cb to the dequeued job.
   *
   * @param {String} type Omit type to handle all the job types
   * @param {Function} cb, will be called with arguments:
   *   - err, if there is any error encountered
   *   - job, the job data object
   *   - done(cancel, last), a function that must be invoked when processing is finished. 
   *       If cancel is true, the job will be returned to the queue.
   *       If last is true, the callback will not be called anymore.
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.process = function(type, cb) {
    if (typeof type === 'function' && !cb) {
      cb = type;
      type = '*';
    }
    if (typeof cb !== 'function') throw new Error('process method requires a callback function.');
    var self = this;
    
    function processJob(err, job) {
      function done(cancel, last) {
        if (cancel) {
          self.cancelRun(job, function(err) {
            if (err) logger.error(err);
            if (!last) process.nextTick(runJob);
          });
        } else {
          self.finish(job, function(err) {
            if (err) logger.error(err);
            else if (!last) process.nextTick(runJob);
          });
        }
      }
      cb(err, job, done);
    }
    
    function runJob() {
      self.dequeue({type:type, state:STATES.RUN}, function(err, jobId){
        if (err || !jobId) return cb(err);
        getJobById(self._rc, jobId, processJob);
      });
    }
    runJob();
    return this;
  };

  /** 
   * Get a job type that has the longest queue among all.
   * @param {function(Error, String)} cb(err, type)
   * @return {JobQueue} for chaining
   */
  $proto.longestQueue = function(cb) {
    var multi = this._rc.multi();
    this._rc.smembers(RKEY.JOBTYPES, function(e, types) {
      if (e) return cb(e);
      types.forEach(function(type) {
        multi.scard(RKEY.state(type, STATES.QUEUE));
      });
      multi.exec(function(err, count) {
        if (err) return cb(err);
        var max = 0;
        var type;
        for (var i = 0; i < count.length; ++i) {
          if (count[i] > max) {
            max = count[i];
            type = types[i];
          }
        }
        return cb(null, type);
      });
    });
    return this;
  };
  
  /**
   * Peek the first element in the queue of a particular type.
   *
   * @param {String} type Use '*' to peek the queue of any type
   * @param {jobIdCallback} cb(err, id)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.peek = function(type, cb) {
    var self = this;
    // get a list of all priorities
    self._rc.zrange(RKEY.priorities(type), 0, -1, function(err, priorities){
      if (err || !priorities || priorities.length === 0) cb(err);
      var pIndex = 0;
      (function peekList() {
        self._rc.lrange(RKEY.queue(type, priorities[pIndex]), 0, 0, function(err, arr){
          if (!err && arr.length > 0) cb(null, arr[0]);
          else if ((++pIndex) < priorities.length) process.nextTick(peekList);
          else cb(err); //return nothing, queue is empty
        });
      })();
    });
    return this;
  };
  
  /**
   * Reserve the first job in the queue for future processing. Use confirmReserve(id) and cancelReserve(id) thereafter.
   * This operation removes a job from the queue and put in STATES.WAIT temporarily
   * Returns a job in the callback: cb(err, job)
   * @param {String} type Use '*' to peek the queue of any type
   * @param {jobCallback} cb(err, job)
   * @return {JobQueue} for chaining
   */
  $proto.reserve = function(type, cb) {
    var rc = this._rc;
    return this.dequeue({type:type, state:STATES.WAIT, timeout:1}, function(err, jobId) {
      getJobById(rc, jobId, cb);
    });
  };
  
  /**
   * Cancel the reserve by putting the job back at the head of the queue
   * @param {Job} job
   * @param {errorCallback} cb(err)
   * @return {JobQueue} for chaining
   */
  $proto.cancelReserve = function(job, cb) {
    return this.cancelDequeue(job, cb, STATES.WAIT);
  };
  
  /**
   * Confirm the reserve by changing the state to RUN
   * @param {Job} job
   * @param {errorCallback} cb(err)
   * @return {JobQueue} for chaining
   */
  $proto.confirmReserve = function(job, cb) {
    var rc = this._rc;
    var id = job.id;
    var type = job.type;
    var state = job.state;
    if (type && state) {
      next();
    } else {
      rc.hget(RKEY.job(id), 'type', 'state', function(e, r) {
        type = r[0];
        state = r[1];
        if (type && state) next();
      });
    }
    function next() {
      if (state === STATES.WAIT) {
        mSetJobState(rc.multi(), id, type, STATES.RUN, STATES.WAIT).exec(cb);
      } else {
        cb();
      }
    }
    return this;
  };
  
  /**
   * Cancel the processed job and put the job back at the head of the queue
   * @param {Job} job
   * @param {errorCallback} cb(err)
   * @return {JobQueue} for chaining
   */
  $proto.cancelRun = function(job, cb) {
    return this.cancelDequeue(job, cb, STATES.RUN);
  };
  
  /** Move job back to the front of queue */
  $proto.cancelDequeue = function(job, cb, restrictState) {
    var rc = this._rc;
    var id = job.id;
    var type = job.type;
    var priority = job.priority;
    var state = job.state;
    if (type && priority && state) {
      next();
    } else {
      rc.hget(RKEY.job(id), 'type', 'priority', 'state', function(e, r) {
        type = r[0];
        priority = r[1];
        state = r[2];
        if (type && priority && state) next();
      });
    }
    function next() {
      restrictState = restrictState || state;
      if (state === restrictState) {
        var multi = rc.multi();
        mSetJobState(multi, id, type, STATES.QUEUE, state);
        multi.zadd(RKEY.priorities(type), priority, priority);
        multi.zadd(RKEY.priorities('*'), priority, priority);
        multi.lpush(RKEY.queue(type, priority), id);
        multi.lpush(RKEY.queue('*', priority), id);
        multi.exec(cb);
      } else {
        cb();
      }
    }
    return this;
  };
  
  /**
   * Change the state of a job from RUN to END
   * @param {Job} job
   * @param {errorCallback} cb(err)
   * @return {JobQueue} for chaining
   */
  $proto.finish = function(job, cb) {
    var rc = this._rc;
    var id = job.id;
    var type = job.type;
    var state = job.state;
    if (type && state) {
      next();
    } else {
      rc.hget(RKEY.job(id), 'type', 'state', function(e, r) {
        if (e) return cb(e);
        type = r[0];
        state = r[1];
        if (type && state) next();
      });
    }
    function next() {
      if (state === STATES.RUN) {
        mSetJobState(rc.multi(), id, type, STATES.END, state).exec(cb);
      } else {
        cb();
      }
    }
    return this;
  };
  
  /**
   * Get the list of submitted job types.
   * @param {function([String])} cb(err, types)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.types = function(cb) {
    //this._rc.smembers(RKEY.JOBTYPES, cb);
    this._rc.sort(RKEY.JOBTYPES, 'ALPHA', cb);
    return this;
  };
  
  /**
   * Returns a list of job id with the given `state`
   *
   * @param {String} options.type
   * @param {String} options.state
   * @param {Function} cb (err, {Array of id}ids)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.jobs = function(options, cb) {
    if (options.type) {
      if (options.state) this._rc.sort(RKEY.state(options.type, options.state), cb);
      else this._rc.sort(RKEY.type(options.type), cb);
    } else if (options.start != null && options.stop != null) {
      // start, stop are zero-based indexes
      this._rc.sort(RKEY.JOBS, 'LIMIT', options.start, options.stop, cb);
    }
    return this;
  };
  
  /**
   * Get the number of jobs in a particular type and state.
   *
   * @param {String} options.type
   * @param {String} options.state
   * @param {Function} cb (err, {Number} @n the number of queue)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.jobsCount = function(options, cb) {
    if (options.type) {
      if (options.state) this._rc.scard(RKEY.state(options.type, options.state), cb);
    }
    return this;
  };
  
  /**
   * Get the job with the specified id.
   *
   * @param {String} id
   * @param {jobCallback} cb(err, job)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.job = function(id, cb) {
    getJobById(this._rc, id, cb);
    return this;
  };
  
  /**
   * Get the state of the job with the specified id.
   *
   * @param {String} id
   * @param {function(String)} cb(err, state)
   * @return {JobQueue} for chaining
   * @api public
   */
  $proto.jobState = function(id, cb) {
    getJobState(this._rc, id, cb);
    return this;
  };
  
  /**
   * Disconnect the connection to Redis server gracefully
   */
  $proto.quit = function() {
    this._rc.quit();
    return this;
  };
  
  return JobQueue;
});

/** cb(err, {String} state)*/
function getJobState(rc, jobId, cb) {
  rc.hget(RKEY.job(jobId), 'state', cb);
}

/** cb(err, {String} state)*/
function getJobType(rc, jobId, cb) {
  rc.hget(RKEY.job(jobId), 'type', cb);
}

function mSetJobState(multi, jobId, jobType, newState, prevState) {
  var now = Date.now();
  multi.hmset(RKEY.job(jobId), 'state', newState, 'updatedAt', now);
  if (newState) multi.sadd(RKEY.state(jobType, newState), jobId);
  if (prevState) multi.srem(RKEY.state(jobType, prevState), jobId);
  return multi;
}

function getJobById(rc, id, cb) {
  rc.hgetall(RKEY.job(id), function(err, obj) {
    var job;
    if (!err && obj) {
      obj.id = id;
      if (obj.data) {
        try {
          obj.data = JSON.parse(obj.data);
        } catch (e) {}
      }
      job = new Job(obj);
    }
    //logger.debug(job);
    cb(err, job);
  });
}

function mRemoveJobState(multi, id, type, state, priority) {
  multi.srem(RKEY.state(type, state), id);
  if (state === STATES.QUEUE) {
    multi.lrem(RKEY.queue(type, priority), 1, id);
  }
}

function mAddJobState(multi, id, type, state, priority) {
  multi.sadd(RKEY.state(type, state), id);
  if (state === STATES.QUEUE) {
    multi.rpush(RKEY.queue(type, priority), id);
  }
}

// Expose `Job`.
//exports.Job = Job;

/**
 * @callback errorCallback
 * @param {Error} error
 */
/**
 * @callback jobIdCallback
 * @param {Error} error
 * @param {String} id
 */
/**
 * @callback jobCallback
 * @param {Error} error
 * @param {Job} job
 */
