/*!
 * redis-jobq
 * Usage example:
 * var JobQueue = require('JobQueue');
 * var jobs = new JobQueue();
 * jobs.submit
 *
 * jq:jobTypes set
 * jq:job:<id> hash
 * jq:jobs set
 * jq:jobs:<type> set
 * jq:jobs:<type>:queue set
 * jq:jobs:<type>:queue:priorities sortedset
 * jq:jobs:<type>:queue:<priority> list
 * jq:jobs:<type>:run set
 * jq:jobs:<type>:hold set
 * jq:jobs:<type>:wait set
 * jq:jobs:<type>:end set
 * jq:jobs:<type>:reserve set
 */

// Module dependencies.
var EventEmitter = require('events').EventEmitter;
var Class = require('jsx').Class;
var Options = require('jsx').Options;
var logger = require('jsx').Logger(module);
var redis = require('redis');

var noop = function(){};

function isUndef(v){
  return (typeof v === 'undefined');
}

function errorSameState(state) {
  return new Error('Job is already in state `' + state + '`.');
}
function errorTypeNumber(v) {
  return new Error('Value of ' + v + ' must be a number.');
}
function errorUneditable(jobId) {
  return new Error('Any changes to job ' + jobId + ' is not allowed at this state.');
}

var STATES = {
      QUEUE: 'queue',
      RUN: 'run',
      HOLD: 'hold', // paused by request
      WAIT: 'wait', //scheduled job
      END: 'end'
};

var PRIORITIES = {
      LOW: 10,
      NORMAL: 0,
      HIGH: -10,
      CRITICAL: -20
};

var RKEY = {};
RKEY.JOBTYPES = 'jq:jobTypes';
RKEY.JOBS = 'jq:jobs';
RKEY.JOB_PREFIX = 'jq:job:';
RKEY.JOBS_PREFIX ='jq:jobs:';
RKEY.type = function(type) { return RKEY.JOBS_PREFIX + type };
RKEY.job = function(id) { return RKEY.JOB_PREFIX + id };
RKEY.priorities = function(type) { return RKEY.JOBS_PREFIX + type + ':' + STATES.QUEUE + ':priorities'};
RKEY.queue = function(type, priority) { return RKEY.JOBS_PREFIX + type + ':' + STATES.QUEUE + ':' + priority; };
RKEY.state = function(type, state) { return RKEY.JOBS_PREFIX + type + ':' + state };
/*
var Job = Class('Job', {
  _static: {
  },
  set: function(key, val, cb) {
    this.jobQueue._rc.hset('jq:jobs:' + this.id, key, val, cb || noop);
    return this;
  },

});
*/
function removeJobState(multi, id, type, state, priority) {
  multi.srem(RKEY.state(type, state), id);
  if (state === STATES.QUEUE) {
    multi.lrem(RKEY.queue(type, priority), 1, id);
  }
}
function addJobState(multi, id, type, state, priority) {
  multi.sadd(RKEY.state(type, state), id);
  if (state === STATES.QUEUE) {
    multi.rpush(RKEY.queue(type, priority), id);
  }
}

function createWritableProperty(obj, key, val, getfn, setfn) {
  var pkey = '_' + key;
  if (isUndef(getfn)) getfn = function() { return obj[pkey]; };
  if (isUndef(setfn)) setfn = function(value){ obj._modified = true;  obj[pkey] = value; };
  Object.defineProperty(obj, pkey, { value: val, writable : true });
  Object.defineProperty(obj, key, { enumerable : true, get : getfn, set : setfn });
}

function createReadonlyProperty(obj, key, val) {
  var pkey = '_' + key;
  Object.defineProperty(obj, pkey, { value: val, writable : true });
  Object.defineProperty(obj, key, {
    enumerable : true,
    get : function() { return obj[pkey]; }
  });
}

var Job = Class('Job', {
  _static : { PRIORITIES: PRIORITIES, STATES: STATES },
  _init : function Job(properties) {
    var data = properties.data;
    delete properties.data;
    var p = Options(properties, {
      _modified : true,
      id : 0,
      type : 'default',
      priority : PRIORITIES.NORMAL,
      state : undefined,
      attempts : 0,
      maxAttempts : 1,
      createdAt : (new Date()).toJSON(),
      updatedAt : 0,
      runAt : 0,
      endAt : 0
    });
    Object.defineProperty(this, '_modified', { value: p._modified, writable:true });
    Object.defineProperty(this, 'id', { value: p.id, enumerable:true });
    createWritableProperty(this, 'type', p.type);
    this.data = data;
    createWritableProperty(this, 'priority', p.priority, undefined, this.setPriority );
    createReadonlyProperty(this, 'state', p.state);
    createReadonlyProperty(this, 'attempts', p.attempts);
    createWritableProperty(this, 'maxAttempts', p.maxAttempts);
    Object.defineProperty(this, 'createdAt', { value: p.createdAt, enumerable:true });
    createReadonlyProperty(this, 'updatedAt', p.updatedAt);
    createReadonlyProperty(this, 'runAt', p.runAt);
    createReadonlyProperty(this, 'endAt', p.endAt);
  },
  setPriority: function(val) {
    if (typeof val !== 'number') throw errorTypeNumber('val');
    this._modified = true;
    this._priority = val;
    return this;
  }
});

module.exports = 
Class('JobQueue', {
  _extends: EventEmitter,

  /** 
   * Create a new job Queue. 
   * @param options {port: {Number} port number, host: {String} host name or IP Address, db: {Number} redis db index, options: {Object} redis options}
   * defaults: {port: 6379, host:127.0.0.1, db:0}
   * @api public 
   */
  _init: function JobQueue(options) {
    var redisClient;
    if (options) {
      redisClient = redis.createClient(options.port, options.host, options.redis);
      if (options.db) redis.select(options.db, noop);
    }
    else redisClient = redis.createClient();

    /** Redis Client */
    this._rc = redisClient;

    this.maxAttempts = 1;
  },

  /**
   * Create a job with the given options containing `type`, `data` and `priority`, and assign a unique id to the job. This will return a job with no state. Use JobQueue.submit() to start queueing.
   * jobs.create('email',{}, function(job) { jobs.submit(job); } );
   *
   * @param {object} options = {string} type, {object} data, {number} priority
   * @param {object} cb(job)
   * - @param {Job} job the created Job
   * @api public
   */
  create: function(options, cb) {
    var self = this;
    this._rc.incr('jq:jobs:lastId', function(err, id){
      if (err) return cb();
      //console.log(this);
      var job = new Job({ 'id' : id, 'type' : options.type, 'data' : options.data, 'priority' : options.priority });
      self.save(job, function(err){
        if (err) { 
          logger.error(err);
          cb();
        } else {
          cb(job);
        }
      });
    });
  },
  save : function(job, cb) {
    if (job.state === STATES.RUN) throw errorUneditable(job.id);

    cb = cb || noop;
    var self = this;
    var rc = this._rc;
    var key = RKEY.job(job.id);
    var now = (new Date()).toJSON();
    // check if this object has been modified and compare with existing value
    if (job._modified) {
      job._modified = false;
      var multi = rc.multi();
      if (job.updatedAt === 0) {
        logger.debug('save new job');
        // A newly created job that has never been saved
        var jobhash = {
            "type": ''+job.type,
            "data": JSON.stringify(job.data),
            "priority": ''+job.priority,
            "attempts": ''+job.attempts,
            "maxAttempts": ''+job.maxAttempts,
            "createdAt": ''+job.createdAt,
            "updatedAt": ''+now,
            "runAt": ''+job.runAt,
            "endAt": ''+job.endAt
        };
        multi
          .sadd(RKEY.JOBTYPES, job.type)
          .sadd(RKEY.JOBS, job.id)
          .sadd(RKEY.type(job.type), job.id)
          .hmset(key, jobhash)
          .exec(cb);

      } else {
        logger.debug('update existing job');
        // Job has been saved previously, just need to update the modified properties
        // ie: type, priority, data
        rc.hget(key, 'type', function(err, prevType) {
          rc.hget(key, 'priority', function(err, prevPriority) {
            if (job.type !== prevType) {
              multi.hset(key, 'updatedAt', now);
              multi.hset(key, 'type', job.type);
              multi.srem(RKEY.type(job.type), job.id);
              multi.sadd(RKEY.type(job.type), job.id);
              if (job.priority !== prevPriority) {
                multi.hset(key, 'priority', job.priority);
              }
              if (job.state) {
                removeJobState(multi, job.id, prevType, job.state, prevPriority);
                addJobState(multi, job.id, job.type, job.state, job.priority);
              }
              multi.exec(cb);
            } else if (job.priority !== prevPriority) {
              multi.hset(key, 'priority', job.priority);
              if (job.state === STATES.QUEUE) {
                multi.lrem(RKEY.queue(job.type, prevPriority), 1, job.id);
                multi.rpush(RKEY.queue(job.type, job.priority), job.id);
              }
              multi.exec(cb);
            }
          });
        });
      }
      job._updatedAt = now;
    } else {
      // always save data because it is impossible to mark any modification
      saveData();
    }

    function saveData() {
      var data = JSON.stringify(job.data);
      // get data from redis
      rc.hget(key, 'data', function(e, r) {
        if (!r || (r && ((r.length !== data.length) || (r !== data)))) {
          // save data
          rc.hmset(key, 'data', data, 'updatedAt', now, function(e, r) { cb(); });
          job._updatedAt = now;
        } else {
          cb(e);
        }
      })
    }

    return this;
  },
  
  /**
   * Enqueue a newly created Job to the queue.
   */
  submit: function(job, cb) {
    if (job.state in {run:'run', wait:'wait', queue:'queue'}) throw new Error('Submitting a job in a state run, wait, or queue is not allowed.');
    cb = cb || noop;
    var sq = STATES.QUEUE;
    var multi = this._rc.multi();
    multi.hset(RKEY.job(job.id), 'state', sq);
    multi.sadd(RKEY.state(job.type, sq), job.id);
    if (job.state) multi.srem(RKEY.state(job.type, job.state), job.id);
    multi.zadd(RKEY.priorities(job.type), job.priority, job.priority); // Add a priority to priorities sorted set
    multi.rpush(RKEY.queue(job.type, job.priority), job.id);
    multi.exec(function(e, r){
      if (e) logger.error(e);
      job.state = sq;
      cb(e);
    });
    return this;
  },

  /** Low level function, use submit() instead */
  enqueue: function(job, cb) {
  },

  /**
   * Process jobs with the given `type`, invoking `cb(job, done)`.
   * Calling this method will automatically and continuously dequeue the queue and perform the function cb to the dequeued job.
   *
   * @param {String} type
   * @param {Function} cb, will be called with arguments:
   *   - job, the job data object
   *   - done, a function that must be invoked when processing is finished
   * @api public
   */
  process: function(type, cb) {
  }

  /**
   * Get the list of submitted job types.
   * @param {Function} cb (err, {Array of String}types)
   * @return {Queue} for chaining
   * @api public
   */
, types: function(cb) {
    //this._rc.smembers(RKEY.JOBTYPES, cb);
    this._rc.sort(RKEY.JOBTYPES, 'ALPHA', cb);
    return this;
  }
  /**
   * Return job ids with the given `state`.
   *
   * @param {String} type
   * @param {String} state
   * @param {Function} cb (err, {Array of id}ids)
   * @return {Queue} for chaining
   * @api public
   */
, state: function(type, state, cb) {
    this._rc.sort(RKEY.state(type, state), cb);
    return this;
  }
  /**
   * Get the number of jobs in a particular type and state.
   *
   * @param {String} type
   * @param {String} state
   * @param {Function} cb (err, {Number} @n the number of queue)
   * @return {Queue} for chaining
   * @api public
   */
, count: function(type, state, cb) {
    this._rc.scard(RKEY.state(type, state), cb);
    return this;
  },
  /** Get a job type that has the longest queue among all. */
  longestQueue: function(cb) {
    var multi = this._rc.multi();
    this._rc.smembers(RKEY.JOBTYPES, function(e, types) {
      types.forEach(function(type) {
        multi.scard(RKEY.state(type, STATES.QUEUE));
      });
      multi.exec(function(err, count) {
        var max = 0;
        var q;
        for (var i = 0; i < count.length; ++i) {
          if (count[i] > max) {
            max = count[i];
            q = types[i];
          }
        }
        return cb(q);
      });
    });
  },
  /** This is a low level API, use `process` is preferred.
   * @param timeout {integer} maximum number of seconds to block, 0 means block indefinitely
   */
  dequeue: function(type, timeout, cb) { 
    logger.debug('[JobQueue.dequeue(%s, %s, cb)]', type, timeout);
    if (!cb && (typeof timeout === 'function')) { 
      cb = timeout;
      timeout = undefined;
    } else {
      cb = cb || noop;
    }
    var rc = this._rc;
    // get a list of all priorities
    rc.zrange(RKEY.priorities(type), 0, -1, function(err, priorities) {
      logger.debug('priorities='+priorities);
      if (err || !priorities || priorities.length == 0) return cb();
      var pIndex = 0;
      (function popList() {
        logger.debug('lpop: ' + RKEY.queue(type, priorities[pIndex]));
        rc.lpop(RKEY.queue(type, priorities[pIndex]), lpopHandler);
      })();
      function lpopHandler(err, arr){
        logger.debug(arr);
        if (!err && arr.length > 0) {
          var id = arr[0];
          rc.srem(RKEY.state(type, STATES.QUEUE), id, function(e, r) {
            cb(id);
          });
        } else if ((++pIndex) < priorities.length) { 
          process.nextTick(popList);
        } else {
          cb(); //return nothing, all queues are empty
        }
      }
    });
    return this;
  },
  /**
   * Peek the first element in the queue of a particular type.
   *
   * @param {String} type
   * @param {Function} cb (@jobId {number} the returned Job)
   * @return {Queue} for chaining
   * @api public
   */
  peek: function(type, cb) {
    var self = this;
    // get a list of all priorities
    self._rc.zrange(RKEY.priorities(type), 0, -1, function(err, priorities){
      if (err || !priorities || priorities.length == 0) cb();
      var pIndex = 0;
      (function peekList() {
        self._rc.lrange(RKEY.queue(type, priorities[pIndex]), 0, 0, function(err, arr){
          if (!err && arr.length > 0) cb(arr[0]);
          else if ((++pIndex) < priorities.length) process.nextTick(peekList);
          else cb(); //return nothing, queue is empty
        });
      })();
    });
    return this;
  },
  /**
   * Reserve the first job in the queue for future processing. Use confirmReserve(id) and cancelReserve(id) thereafter.
   * Returns a job in the callback: cb(job)
   */
  reserve: function(type, cb) {
    var rc = this._rc;
    var self = this;
    return self.dequeue(type, function(id) {
      logger.debug('id='+id);
      if (!id) return cb();
      rc.sadd(RKEY.state(type, 'reserve'), id, function(e, r) { 
        self.getJobById(id, cb);
      });
    });
  },
  cancelReserve: function(id, cb) {
    var rc = this._rc;
    // check id
    rc.hget(RKEY.job(id), 'type', 'priority', function(e, r) {
      var type = r[0];
      var priority = r[1];
      if (type) {
        rc.sismember(RKEY.state(type, 'reserve'), id, function(e, isMember) {
          if (isMember) {
            var multi = rc.multi();
            multi.srem(RKEY.state(type, 'reserve'), id);
            multi.sadd(RKEY.state(type, STATES.QUEUE), id);
            multi.lpush(RKEY.queue(type, priority), id);
            multi.exec(cb);
          }
        });
      }
    });
    return this;
  },
  confirmReserve: function(id, cb) {
    var rc = this._rc;
    rc.hget(RKEY.job(id), 'type', function(e, type) {
      if (type) {
        rc.sismember(RKEY.state(type, 'reserve'), id, function(e, isMember) {
          if (isMember) {
            var multi = rc.multi();
            multi.srem(RKEY.state(type, 'reserve'), id);
            multi.sadd(RKEY.state(type, STATES.RUN), id);
            multi.hset(RKEY.job(id), 'state', STATES.RUN);
            multi.exec(cb);
          }
        });
      }
    });
    return this;
  },
  finish: function(job, cb) {
    var key = RKEY.job(job.id);
    var now = (new Date()).toJSON();
    // change state to 'end' and save output data
    job.state = STATES.END;
    job._updatedAt = now;
    var multi = this._rc.multi();
    multi.srem(RKEY.state(job.type, STATES.RUN), job.id);
    multi.sadd(RKEY.state(job.type, STATES.END), job.id);
    multi.hmset(key, 'state', job.state, 'data', JSON.stringify(job.data), 'updatedAt', now, 'runStatus', job.runStatus);
    multi.exec(cb);
  },
  /**
   * Get the job with the specified id.
   *
   * @param {number} id
   * @param {function} cb (@job {Job} the returned Job, if any)
   * @return {JobQueue} for chaining
   * @api public
   */
  getJobById : function(id, cb) {
    this._rc.hgetall( RKEY.job(id), function(err, obj) {
      var job;
      if (!err && obj) {
        obj._modified = false;
        obj.id = id;
        obj.data = JSON.parse(obj.data);
        job = new Job(obj);
      }
      //logger.debug(job);
      cb(job);
    });
    return this;
  },
  getJobIdsByRange : function(start, stop, cb) {
    /// start, stop are zero-based indexes
    this._rc.sort(RKEY.JOBS, 'LIMIT', start, stop, cb);
  },

  getJobIdsByType : function(type, cb) {
    this._rc.sort(RKEY.type(type), cb);
  },

  getJobState : function(id, cb) {
    this._rc.hget(RKEY.job(id), 'state', cb);
  }
});

// Expose `Job`.
//exports.Job = Job;
